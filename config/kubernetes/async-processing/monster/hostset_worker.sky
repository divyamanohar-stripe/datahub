# DO NOT EDIT: http://go/vendor-skycfg
# This file defines data structures that describe a Monster "host set".
# See http://go/monster-hostset-decl for detailed documentation.

load("config/kubernetes/async-processing/monster/util.sky", "ALL_CLUSTERS", "dynamic_replicas")

DEFAULT_WORKER_COUNT = 2
DEFAULT_MB_PER_WORKER = 2200

# Scaling values are per-mille (out of 1000) to work with integer math, since
# Skycfg doesn't do floats.
DEFAULT_WORKER_MEM_SCALES = {
    "northwest": 1000,

    # on lower throughput clusters, provisioning larger instances,
    # with fewer replicas is currently believed to be superior
    # to adding extra replicas for low traffic use cases
    "bom": 1100,
    "cmh": 1100
}

# Declares a cluster, or template cluster, describing worker replica counts
# and memory allocation per worker replica. There are varying ways to call
# this function. Defaults apply in a cascading fashion, with the first
# non-empty value encountered being used:
#
#   - values for a given cluster
#   - values for per-environment defaults (template)
#   - values for per-isolation-group defaults (template)
#   - global fallback values (template)
#
# For more details, see the user guide at http://go/monster-hostset-decl.
def cluster(
        consume_replicas=None,
        fanout_replicas=None,
        config_replicas=None,
        mb_per_worker=None,
):
    return struct(
        consume=consume_replicas,
        fanout=fanout_replicas,
        config=config_replicas,
        mb_per_worker=mb_per_worker,
    )

# (Private API) Helper function to return the first non-None value from a list
# of arguments. The typical Skycfg idiom "foo or bar" doesn't work because
# zero is false-y, so it gets treated the same as None.
#
# Returns None if there are no non-None values in vals.
def _first_set(*vals):
    for val in vals:
        if val != None:
            return val

    return None

# (Private API) Returns a template cluster for worker defaults based on the
# global constants for worker counts and memory per worker.
def _global_default_template_cluster():
    return cluster(
        consume_replicas=DEFAULT_WORKER_COUNT,
        fanout_replicas=DEFAULT_WORKER_COUNT,
        config_replicas=DEFAULT_WORKER_COUNT,
        mb_per_worker=DEFAULT_MB_PER_WORKER,
    )

# (Test API) Defines a "worker defaults" to hold default values. Only test
# code actually calls this, to set stable defaults so assertions don't depend
# on production defaults. Do not use in production.
def worker_defs(template_cluster=_global_default_template_cluster(),
                worker_mem_scales_per_cluster=DEFAULT_WORKER_MEM_SCALES):
    if template_cluster == None:
        fail("template_cluster cannot be None in worker_defs")

    if template_cluster.consume == None \
        or template_cluster.fanout == None \
        or template_cluster.config == None \
        or template_cluster.mb_per_worker == None:
        fail("template_cluster cannot have any unset fields in worker_defs")

    return struct(
        template=template_cluster,
        worker_mem_scales=worker_mem_scales_per_cluster,
    )

# (Private API) Executes the default cascade given a new template cluster,
# returning a new worker defaults. Non-empty values from the new template
# cluster will replace the corresponding values in the "old" worker defaults.
def _merge_templates(new_cluster, old_defs):
    if new_cluster == None:
        return old_defs

    template = cluster(
        consume_replicas=_first_set(new_cluster.consume, old_defs.template.consume),
        fanout_replicas=_first_set(new_cluster.fanout, old_defs.template.fanout),
        config_replicas=_first_set(new_cluster.config, old_defs.template.config),
        mb_per_worker=_first_set(new_cluster.mb_per_worker, old_defs.template.mb_per_worker),
    )

    return worker_defs(template_cluster=template,
                       worker_mem_scales_per_cluster=old_defs.worker_mem_scales)

# (Private API) Calculates a scaled memory value, using integer math and a
# per-mille (out of 1000) scale factor.
def scale_mem(base, scale):
    return base * scale // 1000  # integer math ftw

# (Private API) Calculates the worker memory limit for a cluster, applying any
# relevant scale factor.
def worker_mem(cluster, cluster_name, defs):
    scale = defs.worker_mem_scales.get(cluster_name, 1000)

    return _first_set(
        cluster.mb_per_worker,
        scale_mem(defs.template.mb_per_worker, scale))

# (Private API) Creates a final JSON document containing, for a given cluster,
# all of the properties of a worker relevant to deployments. Final values are
# looked up according to the default cascade if necessary.
def render_cluster(cluster_map, cluster_name, defs):
    c = cluster_map.get(cluster_name, cluster())
    return {
        cluster_name: {
            "consume": _first_set(c.consume, defs.template.consume),
            "fanout": _first_set(c.fanout, defs.template.fanout),
            "config": _first_set(c.config, defs.template.config),
            "mb_per_worker": worker_mem(c, cluster_name, defs),
        }
    }

# (Private API) Creates a final JSON document containing, for a given
# environment (prod, qa), all of the worker properties relevant to
# deployments. This is the union of the result of `render_cluster`, for each
# cluster known.
def render_env(env_map, defs):
    # short-hand for per-env default
    if type(env_map) != "dict":
        env_map = {"default": env_map}

    defs = _merge_templates(env_map.get("default"), defs)
    json = {}
    for cluster_name in ALL_CLUSTERS:
        json.update(render_cluster(env_map, cluster_name, defs))

    return json

# Creates a deployment declaration for an isolation group (aka host-set). For
# more details, see the user guide at http://go/monster-hostset-decl.
def hostset(name, default=None, qa=None, prod=None, is_canary=False, shared_msp=False, defs=worker_defs(), suffix=""):
    # Setting suffix will add to it to the k8s service name
    # nothing else would change, so that capacity would share the same consul service name as main capacity
    # Similarly, setting is_canary will add "-canary" (after the suffix, if any)

    defs=_merge_templates(default, defs)
    qa_json = render_env(qa or {}, defs)
    prod_json = render_env(prod or {}, defs)

    return struct(name=name, qa=qa_json, prod=prod_json, is_canary=is_canary, shared_msp=shared_msp, suffix=suffix)
