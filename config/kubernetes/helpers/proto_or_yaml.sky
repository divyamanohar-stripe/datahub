# DO NOT EDIT: http://go/vendor-skycfg
load("config/kubernetes/helpers/context.sky", "get_render_yaml")

_apps = proto.package("k8s.io.api.apps.v1")
_batch = proto.package("k8s.io.api.batch.v1")
_batch_beta1 = proto.package("k8s.io.api.batch.v1beta1")
_core = proto.package("k8s.io.api.core.v1")
_meta = proto.package("k8s.io.apimachinery.pkg.apis.meta.v1")
_rbac = proto.package("k8s.io.api.rbac.v1")
_resource = proto.package("k8s.io.apimachinery.pkg.api.resource")
_util = proto.package("k8s.io.apimachinery.pkg.util.intstr")

### Apps v1

def DaemonSet(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.DaemonSet, apiGroup = "apps/v1", kind = "DaemonSet", marshal = True, **kwargs)

def DaemonSetSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.DaemonSetSpec, **kwargs)

def DaemonSetUpdateStrategy(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.DaemonSetUpdateStrategy, **kwargs)

def Deployment(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.Deployment, apiGroup = "apps/v1", kind = "Deployment", marshal = True, **kwargs)

def DeploymentSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.DeploymentSpec, **kwargs)

def DeploymentStrategy(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.DeploymentStrategy, **kwargs)

def RollingUpdateDaemonSet(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.RollingUpdateDaemonSet, **kwargs)

def RollingUpdateDeployment(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.RollingUpdateDeployment, **kwargs)

def RollingUpdateStatefulSetStrategy(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.RollingUpdateStatefulSetStrategy, **kwargs)

def StatefulSet(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.StatefulSet, apiGroup = "apps/v1", kind = "StatefulSet", marshal = True, **kwargs)

def StatefulSetSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.StatefulSetSpec, **kwargs)

def StatefulSetUpdateStrategy(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _apps.StatefulSetUpdateStrategy, **kwargs)

### Batch v1

def Job(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _batch.Job, apiGroup = "batch/v1", kind = "Job", marshal = True, **kwargs)

def JobSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _batch.JobSpec, **kwargs)

def JobTemplateSpec(ctx, **kwargs):
    # TODO: deprecate _batch_beta1; the version of protos imported today aren't up to date
    # and don't have JobTemplateSpec v1.
    return _generic_kubernetes_proto_yaml_conditional(ctx, _batch_beta1.JobTemplateSpec, **kwargs)

def CronJob(ctx, **kwargs):
    # TODO: deprecate _batch_beta1; the version of protos imported today aren't up to date
    # and don't have CronJob v1.
    return _generic_kubernetes_proto_yaml_conditional(ctx, _batch_beta1.CronJob, apiGroup = "batch/v1", kind = "CronJob", marshal = True, **kwargs)

def CronJobSpec(ctx, **kwargs):
    # TODO: deprecate _batch_beta1; the version of protos imported today aren't up to date
    # and don't have CronJobSpec v1.
    return _generic_kubernetes_proto_yaml_conditional(ctx, _batch_beta1.CronJobSpec, **kwargs)

### Core v1

def Affinity(ctx, podAntiAffinity):
    if get_render_yaml(ctx):
        return {
            "podAntiAffinity": podAntiAffinity
        }

    return _core.Affinity(
        podAntiAffinity = podAntiAffinity
    )

def Capabilities(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Capabilities, **kwargs)

def Container(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Container, **kwargs)

def ContainerPort(ctx, containerPort, hostPort, name):
    if get_render_yaml(ctx):
        return {
            "containerPort": containerPort,
            "hostPort": hostPort,
            "name": name
        }

    return _core.ContainerPort(containerPort = containerPort, hostPort = hostPort, name = name)

def EmptyDirVolumeSource(ctx, **kwargs):
    if get_render_yaml(ctx):
        vol = {}

        for key, value in kwargs.items():
            vol[key] = value

        return vol

    return _core.EmptyDirVolumeSource(**kwargs)


def EnvVar(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.EnvVar, **kwargs)

def EnvVarSource(ctx, fieldRef):
    if get_render_yaml(ctx):
        return {
            "fieldRef": fieldRef,
        }

    return _core.EnvVarSource(fieldRef = fieldRef)

def ExecAction(ctx, command):
    if get_render_yaml(ctx):
        return {
            "command": command
        }

    return _core.ExecAction(command = command)

def HTTPGetAction(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.HTTPGetAction, **kwargs)

def HTTPHeader(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.HTTPHeader, **kwargs)


def Handler(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Handler, **kwargs)

def HostPathVolumeSource(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.HostPathVolumeSource, **kwargs)

def Lifecycle(ctx, **kwargs):
    if get_render_yaml(ctx):
        lifecycle = {}

        for key, value in kwargs.items():
            lifecycle[key] = value

        return lifecycle

    return _core.Lifecycle(**kwargs)

def LifecycleHandler(ctx, **kwargs):
    # Support for proto rename to support 1.22 -> 1.23 upgrade. Once we are on 1.23
    # everywhere we can remove this. See
    # https://github.com/kubernetes/api/commit/cca52a076791d31b1796453ece4b2f4df97406a2
    if hasattr(_core, "LifecycleHandler"):
        return _generic_kubernetes_proto_yaml_conditional(ctx, _core.LifecycleHandler, **kwargs)
    else:
        return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Handler, **kwargs)

def ObjectFieldSelector(ctx, fieldPath):
    if get_render_yaml(ctx):
        return {
            "fieldPath": fieldPath,
        }

    return _core.ObjectFieldSelector(fieldPath = fieldPath)


def PodAffinityTerm(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.PodAffinityTerm, **kwargs)


def PodAntiAffinity(ctx, preferredDuringSchedulingIgnoredDuringExecution = [], requiredDuringSchedulingIgnoredDuringExecution = []):
    if get_render_yaml(ctx):
        return {
            "preferredDuringSchedulingIgnoredDuringExecution": preferredDuringSchedulingIgnoredDuringExecution,
            "requiredDuringSchedulingIgnoredDuringExecution": requiredDuringSchedulingIgnoredDuringExecution
        }

    return _core.PodAntiAffinity(
        preferredDuringSchedulingIgnoredDuringExecution = preferredDuringSchedulingIgnoredDuringExecution,
        requiredDuringSchedulingIgnoredDuringExecution = requiredDuringSchedulingIgnoredDuringExecution,
    )

def PodSecurityContext(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.PodSecurityContext, **kwargs)

def PodSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.PodSpec, **kwargs)

def PodTemplateSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.PodTemplateSpec, **kwargs)

def Probe(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Probe, **kwargs)

def ProbeHandler(ctx, **kwargs):
    # Support for proto rename to support 1.22 -> 1.23 upgrade. Once we are on 1.23
    # everywhere we can remove this. See
    # https://github.com/kubernetes/api/commit/cca52a076791d31b1796453ece4b2f4df97406a2
    if hasattr(_core, "ProbeHandler"):
        return _generic_kubernetes_proto_yaml_conditional(ctx, _core.ProbeHandler, **kwargs)
    else:
        return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Handler, **kwargs)

def ResourceRequirements(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.ResourceRequirements, **kwargs)

def SecurityContext(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.SecurityContext, **kwargs)

def Service(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Service, **kwargs)

def ServicePort(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.ServicePort, **kwargs)

def ServiceSpec(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.ServiceSpec, **kwargs)

def TCPSocketAction(ctx, port):
    if get_render_yaml(ctx):
        return {
            "port": port
        }

    return _core.TCPSocketAction(port = port)


def Toleration(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Toleration, **kwargs)

def TopologySpreadConstraint(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.TopologySpreadConstraint, **kwargs)

def Volume(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.Volume, **kwargs)

def VolumeMount(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.VolumeMount, **kwargs)

def VolumeSource(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.VolumeSource, **kwargs)

def WeightedPodAffinityTerm(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _core.WeightedPodAffinityTerm, **kwargs)

### Meta v1

def LabelSelector(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _meta.LabelSelector, **kwargs)

def LabelSelectorRequirement(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _meta.LabelSelectorRequirement, **kwargs)

def ObjectMeta(ctx, **kwargs):
    return _generic_kubernetes_proto_yaml_conditional(ctx, _meta.ObjectMeta, **kwargs)

## Util

def IntOrString(ctx, intVal = None, strVal = None):
    if get_render_yaml(ctx):
        return intVal or strVal

    if intVal != None:
        return _util.IntOrString(intVal = intVal)
    else:
        return _util.IntOrString(type = 1, strVal = strVal)

def Quantity(ctx, string):
    if get_render_yaml(ctx):
        return string

    return _resource.Quantity(string = string)

def _generic_kubernetes_proto_yaml_conditional(ctx, proto, apiGroup = None, kind = None, marshal = False, **kwargs):
    if get_render_yaml(ctx):
        tmp = {}

        if apiGroup:
            tmp["apiGroup"] = apiGroup

        if kind:
            tmp["kind"] = kind

        for key, value in kwargs.items():
            tmp[key] = value

        if marshal:
            return yaml.marshal(tmp)
        else:
            return tmp

    return proto(**kwargs)
