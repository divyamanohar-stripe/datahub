# DO NOT EDIT: http://go/vendor-skycfg
"""
Plugins for adding rules to control how pods are scheduled onto nodes.
"""

load("config/kubernetes/plugins/types.sky", "pod_plugin")

_core = proto.package("k8s.io.api.core.v1")
_meta = proto.package("k8s.io.apimachinery.pkg.apis.meta.v1")

def avoid_pods_with_labels(labels, weight = None):
    """
    Avoid scheduling the pod co-located with other pods with the given labels.

    Creates a pod anti-affinity rule which determines where the pod is allowed to be scheduled. If there is already
    another pod on a node with labels that match the labels in the rule, that node will not be valid for scheduling
    this pod.

    Args:
        labels: A dictionary of labels that match pods that should be avoided.
        weight: An optional weight from 1-100 for how strongly to avoid these pods. Specifying a weight makes the
            rule a preference instead of a requirement, so the pod will be scheduled on the "least bad" node based
            on all rules.

    Returns:
        A plugin that adds the scheduling rule to the pod.
    """
    return _affinity_plugin(
        _pod_affinity_rule(
            selector = _meta.LabelSelector(
                matchLabels = labels,
            ),
            weight = weight,
            negative = True,
        ),
    )

def empty_affinity():
    return {
        "rules": [],
        "highly_available": False,
        "highly_available_zones": (),
    }

def render_affinity(affinity):
    if len(affinity["rules"]) == 0 and not affinity["highly_available"]:
        return None

    pod_anti_affinity = _core.PodAntiAffinity(
        preferredDuringSchedulingIgnoredDuringExecution = [],
        requiredDuringSchedulingIgnoredDuringExecution = [],
    )

    for rule in affinity["rules"]:
        if rule.type == "pod":
            if not rule.negative:
                fail("Pod affinity rules haven't been implemented yet")

            term = _render_pod_affinity_term(rule)
            if rule.weight == None:
                pod_anti_affinity.requiredDuringSchedulingIgnoredDuringExecution.append(term)
            else:
                pod_anti_affinity.preferredDuringSchedulingIgnoredDuringExecution.append(term)

    if affinity["highly_available"]:
        labelSelector = None
        zones = affinity["highly_available_zones"]
        if zones:
            labelSelector = _meta.LabelSelector(
                matchExpressions = [
                    _meta.LabelSelectorRequirement(
                        key = "topology.kubernetes.io/zone",
                        operator = "In",
                        values = list(zones),
                    ),
                ],
            )
        pod_anti_affinity.preferredDuringSchedulingIgnoredDuringExecution.append(
            _core.WeightedPodAffinityTerm(
                weight = 100,
                podAffinityTerm = _core.PodAffinityTerm(
                    labelSelector = labelSelector,
                    topologyKey="topology.kubernetes.io/zone",
                ),
            ),
        )

    return _core.Affinity(
        podAntiAffinity = pod_anti_affinity,
    )

def _pod_affinity_rule(
    selector,
    namespaces = [],
    topologyKey = "kubernetes.io/hostname",
    weight = None,
    negative = False):
    return struct(
        type = "pod",
        selector = selector,
        namespaces = namespaces,
        topologyKey = topologyKey,
        weight = weight,
        negative = negative,
    )

def _affinity_plugin(rule):
    return pod_plugin(
        _add_affinity_rule,
        rule = rule,
    )

def _add_affinity_rule(ctx, plugin, pod_def):
    pod_def["affinity"]["rules"].append(plugin.rule)

def _render_pod_affinity_term(rule):
    term = _core.PodAffinityTerm(
        labelSelector = rule.selector,
        namespaces = rule.namespaces,
        topologyKey = rule.topologyKey,
    )

    if rule.weight == None:
        return term

    return _core.WeightedPodAffinityTerm(
        weight = rule.weight,
        podAffinityTerm = term,
    )
